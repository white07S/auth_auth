

0) Goals & constraints (from you)
	•	Inputs: client_id, tenant_id, redirect_uri, post_logout_redirect_uri, scopes (e.g., openid, profile, email, offline_access, Graph scopes like memberOf), MIM group IDs.
	•	All pages are protected by default. ProtectedRoute is the single gate; LoggedOut and Login are public.
	•	Use BFF: browser never sees access/refresh tokens; no localStorage; auth state via secure HttpOnly cookie.
	•	RBAC via Microsoft: assign roles from MIM group IDs; no database to maintain.
	•	HashRouter in React.
	•	Config in config.yaml.
	•	Simple file layout (no TSX, minimal components).
	•	Background refresh done server-side.
	•	Multi-user by default.

⸻

1) Microsoft / Entra setup (once)
	1.	Register Web App (BFF)
	•	Type: Web app (confidential client).
	•	Redirect URIs: https://<your-bff>/auth/callback.
	•	Front-channel logout URL: https://<your-bff>/auth/post-logout.
	•	Enable ID tokens.
	•	Add client secret or (preferably) a certificate.
	•	API permissions (delegated): openid, profile, email, offline_access and the minimum Graph scopes for groups (e.g., GroupMember.Read.All or configure Group claims in the token; see §4 RBAC).
	•	Grant admin consent.
	2.	Group Claims (recommended)
	•	In the app manifest, set groupMembershipClaims to SecurityGroup (or All) to receive groups claim in the id_token (handles many cases without hitting Graph).
	•	If “overage” (too many groups) occurs, the token will include a special claim indicating you must call Graph once.

You can either rely on group claims in the id_token or call Graph on login to fetch /me/transitiveMemberOf//getMemberObjects—pick one primary path and keep the other as fallback.

⸻

2) Repo layout & config

/frontend
  /src
    /components
      /auth
        auth.js          # minimal client-side session helper (no tokens)
        api_auth.js      # thin wrapper to hit BFF /auth/* and /api/*
    Header.js
    App.js
    ProtectedRoute.js
    LoggedOut.js
    Login.js
    Home.js, Docs.js, Scenario.js, Chat.js, Task.js, Dashboard.js (all of these goes into pages folder, for now just put some mock info)
  config.yaml            # served at build or baked into bundle as static JSON

/backend
  app.py                 # FastAPI entry, mounts routers, BFF proxy, security
  /auth
    routes.py            # /auth/login, /auth/callback, /auth/logout, /auth/session
    ms_client.py         # MSAL client, token exchange/refresh helpers
    sessions.py          # cookie/session management, CSRF, state/nonce
    claims.py            # groups→roles mapping, allowed routes resolution
  /api
    routes.py            # your app APIs, all behind RBAC decorator/middleware
  /bff
    graph.py             # Graph client calls (memberOf, profile, etc.)
  config.yaml            # same shape as frontend (or a superset)

config.yaml (one source of truth)
	•	tenant_id
	•	client_id
	•	authority_base: https://login.microsoftonline.com
	•	redirect_uri, post_logout_redirect_uri
	•	scopes:
	•	openid, profile, email, offline_access
	•	Graph delegated scopes: minimal needed for groups fallback (e.g., GroupMember.Read.All)
	•	cookie: { name, domain, secure: true, samesite: "Lax"|"Strict", http_only: true, max_age_minutes }
	•	csrf: { cookie_name, header_name }
	•	rbac:
	•	group_to_role:

business_user:
  - "<MIM-GROUP-ID-1>"
  - "<MIM-GROUP-ID-2>"
business_admin:
  - "<MIM-GROUP-ID-ADMIN>"


	•	route_policies:

"/scenario": ["business_user", "business_admin"]
"/chat":     ["business_user", "business_admin"]
"/task":     ["business_user", "business_admin"]
"/dashboard":["business_admin"]
"/docs":     ["business_user", "business_admin"]
"/":         ["business_user", "business_admin"]


	•	session: { refresh_skew_seconds: 300, role_cache_ttl_seconds: 300 }
	•	cors: { allowed_origins: ["https://your-spa-origin"] }

⸻

3) Frontend (React, HashRouter) design

Principles
	•	No tokens in the browser.
	•	No localStorage. Use in-memory React state only.
	•	All auth state comes from /auth/session JSON + secure cookie set by the BFF.

Key pieces
	•	App.js
	•	Wrap with HashRouter.
	•	On initial mount, call GET /auth/session:
	•	if 200: store {user: {name, email}, roles, allowed_routes, exp} in memory context.
	•	if 401: mark isAuthenticated=false.
	•	ProtectedRoute.js
	•	On route mount, re-validate with /auth/session.
	•	If 401, redirect to /#/login.
	•	If 403 (known route but role not allowed), show a simple “Not Authorized” page.
	•	Login.js
	•	A button that calls POST /auth/login (BFF returns a 302 to Microsoft).
	•	After the auth dance, backend redirects to your redirect_uri (e.g., /#/).
	•	LoggedOut.js
	•	Public page encouraging login.
	•	Header.js
	•	Shows app name, current user (if any), and a Logout button → POST /auth/logout (backend signs out + clears cookie).
	•	components/auth/api_auth.js
	•	Thin fetch wrapper sends credentials (cookies) and CSRF header (if method != GET).
	•	Handles 401/403 to trigger redirect or toasts.
	•	components/auth/auth.js
	•	Minimal helpers to pull session from the context; no persistence.

Routing
	•	Use HashRouter so deep links work in static hosting (server needn’t rewrite).
	•	All pages (Home, Docs, Scenario, Chat, Task, Dashboard) are wrapped by ProtectedRoute.

UI behavior
	•	“Everything is protected by default”: any page not explicitly whitelisted is guarded.
	•	Hide/disable nav items in Header based on allowed_routes.

⸻

4) Backend (FastAPI) design

BFF responsibilities
	•	Owns the OAuth/OIDC flow (Authorization Code + PKCE).
	•	Redeems code for tokens using MSAL (server-side).
	•	Stores tokens server-side (preferred) or in encrypted, HttpOnly cookie (stateless mode).
	•	Exposes only session shape to the SPA, never tokens.
	•	Enforces RBAC on all /api/* and proxies any Graph calls on behalf of the user.

Endpoints
	•	POST /auth/login
	•	Creates state + nonce + PKCE verifier.
	•	Stores transient values in a short-lived, signed cookie.
	•	302 to Microsoft authorize endpoint with scopes from config.yaml.
	•	GET /auth/callback
	•	Validates state + nonce.
	•	Exchanges code for id_token, access_token, refresh_token.
	•	Group resolution (pick strategy):
	•	Preferred: read groups claim from id_token when present.
	•	Fallback: one Graph call to fetch group IDs (/me/getMemberObjects or /me/transitiveMemberOf) and cache for role_cache_ttl_seconds.
	•	Map group IDs → roles using rbac.group_to_role.
	•	Compute allowed_routes using rbac.route_policies.
	•	Create session:
	•	Option A (recommended): server-side session store (in-memory with eviction; if you need multiple instances later, switch to Redis without changing the interface).
	•	Option B (stateless): signed, encrypted cookie with minimal claims (sub, name, roles, allowed_routes, exp) and no access/refresh tokens inside; keep tokens server-side only.
	•	Set HttpOnly, Secure, SameSite cookie. Redirect to post-login route (from config).
	•	GET /auth/session
	•	Returns { isAuthenticated, user:{name,email}, roles, allowed_routes, session_expiry }.
	•	POST /auth/logout
	•	Clears session cookie.
	•	(Optionally) call Microsoft front-channel logout.
	•	Redirect to post_logout_redirect_uri.
	•	GET /api/...
	•	All APIs protected by middleware:
	•	Verify session cookie signature & expiry.
	•	Enforce RBAC using route_policies.
	•	If making Graph calls on user’s behalf, ensure access token valid; if expiring soon, refresh server-side before use.
	•	(Optional) GET /auth/ping
	•	Lightweight keep-alive that also lets backend proactively refresh nearing-expiry sessions.

Token lifecycle (background refresh)
	•	Keep access_token lifetime small; rely on refresh_token.
	•	On each request, middleware checks token exp:
	•	If < refresh_skew_seconds, refresh via MSAL silently using the stored refresh_token; rotate refresh token.
	•	If refresh fails, clear session → 401.
	•	If you want to keep users “warm” while idle, the SPA can call /auth/ping every ~5–10 minutes when focused; backend decides if refresh is needed. (No timers in the SPA for tokens themselves.)

Security hardening
	•	Cookies: Secure, HttpOnly, SameSite=Lax (or Strict if your flows permit).
	•	CSRF: for state-changing POST/PUT/DELETE, require a CSRF header matching a server-issued CSRF cookie tied to the session.
	•	Validate state & nonce on the OIDC flow.
	•	CORS: only your SPA origin(s).
	•	Content Security Policy (CSP) on SPA.
	•	Strict input validation on all /api/*.

⸻

5) RBAC with MIM groups (clean & fast)

Primary approach (lowest latency):
	•	Enable group claims in the id_token (app manifest groupMembershipClaims → SecurityGroup).
	•	On callback, read id_token.claims.groups (or hasgroups → do one Graph call if overage).
	•	Use rbac.group_to_role mapping from config.yaml to derive roles.
	•	From roles, compute allowed_routes via rbac.route_policies and include these two arrays in the session object sent to the SPA.

Fallback approach (if no group claims)
	•	Call Graph once per login to fetch group IDs (/me/transitiveMemberOf or /me/getMemberObjects). Cache for a short TTL (e.g., 5 min).
	•	Never expose raw group IDs to the client; only roles and allowed_routes.

No database promise kept
	•	Sessions in memory (or signed cookie) + short TTL cache for groups.
	•	If you ever scale to multiple replicas, switch to Redis for sessions transparently (still “no database” in your app domain).

⸻

6) Page protection & route governance
	•	Frontend:
	•	ProtectedRoute asks /auth/session on navigation.
	•	If isAuthenticated=false: redirect to /#/login.
	•	If isAuthenticated=true but route not in allowed_routes: show 403 view.
	•	Backend:
	•	An RBAC decorator or middleware checks the requested path against route_policies. This is the source of truth; the SPA is just UX.

⸻

7) BFF for Graph & your APIs
	•	The SPA never calls Graph directly.
	•	Your BFF (/bff/graph) calls Graph using the user’s delegated token (on-behalf-of) or the refreshed access_token from the user’s session.
	•	Sanitize and downscope the data before returning to the SPA.

⸻

8) Background refresh “the proper way”
	•	Server-side only:
	•	Maintain exp for both id_token (for claims freshness) and access_token.
	•	Refresh opportunistically if time to expiry < refresh_skew_seconds.
	•	Rotate refresh tokens (MSAL handles).
	•	Do not rely on hidden iframes or SPA refresh hacks (they’re not needed in a BFF).

⸻

9) Extensibility knobs
	•	Add a new page/route:
	1.	Implement page component + add ProtectedRoute.
	2.	Add route to route_policies in config.yaml with allowed roles.
	3.	Redeploy; no code change in RBAC logic.
	•	Add a new role:
	1.	Add a role name in group_to_role with MIM group IDs.
	2.	Reference the role in route_policies.
	•	Change Graph usage:
Update scopes in config.yaml, grant admin consent once; BFF proxy stays unchanged.

⸻

10) Minimal user flows (text sequence)

Login
	1.	SPA → POST /auth/login
	2.	BFF → Microsoft authorize (PKCE, state, nonce)
	3.	Microsoft → GET /auth/callback?code=...&state=...
	4.	BFF validates; redeems code → tokens; resolve groups→roles; set cookie; 302 to /#/
	5.	SPA mounts → GET /auth/session → render protected UI.

API Call
	1.	SPA → GET /api/scenario (with cookie)
	2.	BFF checks session & RBAC; if token near expiry, refresh; call service; return data.

Logout
	1.	SPA → POST /auth/logout
	2.	BFF clears cookie; calls Microsoft logout; 302 to post_logout_redirect_uri.

⸻

11) What goes in each file (at a glance, still no code)

Frontend
	•	App.js: HashRouter, initial /auth/session fetch, AuthContext provider, routes.
	•	ProtectedRoute.js: gate based on /auth/session + allowed_routes.
	•	Header.js: current user display; Login/Logout buttons.
	•	Login.js: single “Sign in with Microsoft” button → /auth/login.
	•	LoggedOut.js: public page for unauthenticated users.
	•	components/auth/api_auth.js: fetch wrapper (credentials included, CSRF header on write methods).
	•	components/auth/auth.js: tiny context helpers, no persistence.

Backend
	•	auth/routes.py: /auth/login, /auth/callback, /auth/logout, /auth/session.
	•	auth/ms_client.py: MSAL client, token redeem/refresh utilities.
	•	auth/sessions.py: cookie signing, state/nonce, CSRF, session encode/decode.
	•	auth/claims.py: read group claims / fallback Graph call; map to roles; compute allowed routes.
	•	bff/graph.py: safe wrappers to call Graph; minimal scopes.
	•	api/routes.py: your business APIs; all pass through RBAC middleware.
	•	app.py: wire it all up; CORS; middlewares (RBAC, CSRF, refresh-on-edge); config loader.

⸻

12) Defaults to set (so you don’t revisit later)
	•	Cookie: Secure, HttpOnly, SameSite=Lax, path /, rotation on login, shortish max-age (e.g., 8–12h).
	•	Session refresh skew: 5 minutes.
	•	Group cache TTL: 5 minutes (keeps RBAC snappy, while reflecting changes reasonably fast).
	•	SPA session poll: only on route change or periodic “ping” when active tab.
